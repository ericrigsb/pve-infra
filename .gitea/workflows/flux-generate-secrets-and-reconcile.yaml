name: Generate Secrets and Reconcile

on:
  push:
    branches:
      - main
    paths:
      - 'cluster/redcloud/**'
  workflow_dispatch: {}

env:
  KUBECONFIG_PATH: /tmp/kubeconfig
  FLUX_NAMESPACE: flux-system

jobs:
  generate_secrets:
    runs-on: ubuntu-latest

    steps:
      - name: Setup kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $KUBECONFIG_PATH
          chmod 600 $KUBECONFIG_PATH

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Ensure cert-manager namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace cert-manager || kubectl create namespace cert-manager

      - name: Create Cloudflare API token secret for cert-manager
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic cloudflare-api-token \
            --namespace cert-manager \
            --from-literal=api-token="${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure mailrise namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace mailrise || kubectl create namespace mailrise

      - name: Create Mailrise Slack API key secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic mailrise-slack \
            --namespace mailrise \
            --from-literal=SLACK_API_URL="${{ secrets.MAILRISE_SLACK_API_URL }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure mongodb namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace mongodb || kubectl create namespace mongodb

      - name: Create MongoDB secrets
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic mongodb-auth \
            --namespace mongodb \
            --from-literal=mongodb-root-password="${{ secrets.MONGODB_ROOT_PASSWORD }}" \
            --from-literal=mongodb-usernames="unifi" \
            --from-literal=mongodb-databases="unifi,unifi_stat,unifi_audit" \
            --from-literal=mongodb-passwords="${{ secrets.MONGODB_PASSWORDS }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure unifi-network-application namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace unifi-network-application || kubectl create namespace unifi-network-application

      - name: Create Unifi DB secret in mongodb namespace
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic unifi-db-secret \
            --namespace mongodb \
            --from-literal=password="${{ secrets.UNIFI_DB_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Unifi Network Application database secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic unifi-db-secret \
            --namespace unifi-network-application \
            --from-literal=password="${{ secrets.UNIFI_DB_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure postgresql namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace postgresql || kubectl create namespace postgresql

      - name: Create PostgreSQL secrets
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic postgresql-auth \
            --namespace postgresql \
            --from-literal=postgres-password="${{ secrets.POSTGRES_SUPERUSER_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure redis namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace redis || kubectl create namespace redis

      - name: Create Redis secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic redis-auth \
            --namespace redis \
            --from-literal=redis-password="${{ secrets.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure immich namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace immich || kubectl create namespace immich

      - name: Create Immich DB secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic immich-db-secret \
            --namespace immich \
            --from-literal=postgres-password="${{ secrets.POSTGRES_SUPERUSER_PASSWORD }}" \
            --from-literal=redis-password="${{ secrets.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure nextcloud namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace nextcloud || kubectl create namespace nextcloud

      - name: Create Nextcloud DB secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic nextcloud-db \
            --namespace nextcloud \
            --from-literal=db-username=postgres \
            --from-literal=db-password="${{ secrets.POSTGRES_SUPERUSER_PASSWORD }}" \
            --from-literal=redis-password="${{ secrets.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Nextcloud admin secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic nextcloud \
            --namespace nextcloud \
            --from-literal=nextcloud-username=admin \
            --from-literal=nextcloud-password="${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Restic secret in app namespaces
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          for namespace in immich nextcloud unifi-network-application uptime-kuma; do
            kubectl create secret generic restic-secret \
              --namespace $namespace \
              --from-literal=password='${{ secrets.RESTIC_REPO_PASSWORD }}' \
              --dry-run=client -o yaml | kubectl apply -f -
          done

      - name: Create Slack webhook secret in app namespaces for backup notifications
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          for namespace in immich nextcloud unifi-network-application uptime-kuma; do
            kubectl create secret generic slack-webhook \
              --namespace $namespace \
              --from-literal=webhook-url="${{ secrets.MAILRISE_SLACK_API_URL }}" \
              --dry-run=client -o yaml | kubectl apply -f -
          done

      - name: Create Gitea registry image pull secrets for backup jobs
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          for namespace in immich nextcloud unifi-network-application uptime-kuma; do
            kubectl create secret docker-registry gitea-registry \
              --namespace=$namespace \
              --docker-server="${{ vars.REGISTRY_HOSTNAME }}" \
              --docker-username="${{ secrets.REGISTRY_USER }}" \
              --docker-password="${{ secrets.REGISTRY_PASSWORD }}" \
              --docker-email="registry@gitea.mesh.rigsb.net" \
              --dry-run=client -o yaml | kubectl apply -f -
          done

      - name: Ensure nutweb namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace nutweb || kubectl create namespace nutweb

      - name: Create Nutweb secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic nutweb-secret \
            --namespace nutweb \
            --from-literal=UPSD_USER="${{ secrets.NUT_USER }}" \
            --from-literal=UPSD_PASS="${{ secrets.NUT_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure external-dns namespace exists
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl get namespace external-dns || kubectl create namespace external-dns

      - name: Create External DNS secret
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          kubectl create secret generic external-dns-secret \
            --namespace external-dns \
            --from-literal=MIKROTIK_BASEURL="${{ vars.MIKROTIK_BASEURL }}" \
            --from-literal=MIKROTIK_USERNAME="${{ secrets.MIKROTIK_USERNAME }}" \
            --from-literal=MIKROTIK_PASSWORD="${{ secrets.MIKROTIK_PASSWORD }}" \
            --from-literal=MIKROTIK_SKIP_TLS_VERIFY="${{ vars.MIKROTIK_SKIP_TLS_VERIFY }}" \
            --from-literal=DOMAIN_FILTER="${{ vars.DOMAIN_FILTER }}" \
            --dry-run=client -o yaml | kubectl apply -f -

  reconcile_flux:
    runs-on: ubuntu-latest
    needs: generate_secrets

    steps:
      - name: Setup kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $KUBECONFIG_PATH
          chmod 600 $KUBECONFIG_PATH

      - name: Install Flux CLI
        run: |
          curl -s https://fluxcd.io/install.sh | sudo bash

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Reconcile all Flux Kustomizations
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          for k in $(kubectl --kubeconfig=$KUBECONFIG_PATH get kustomizations.kustomize.toolkit.fluxcd.io -n $FLUX_NAMESPACE -o name); do
            name=$(echo $k | cut -d/ -f2)
            flux reconcile kustomization $name --namespace=$FLUX_NAMESPACE --kubeconfig=$KUBECONFIG_PATH || true
          done

      - name: Copy backup scripts to app namespaces
        env:
          KUBECONFIG: ${{ env.KUBECONFIG_PATH }}
        run: |
          # Wait for backup-scripts ConfigMap to be available
          echo "Waiting for backup-scripts ConfigMap to be created by Flux..."
          for i in {1..30}; do
            if kubectl get configmap backup-scripts -n backups &>/dev/null; then
              echo "backup-scripts ConfigMap found!"
              break
            fi
            echo "Attempt $i/30: backup-scripts ConfigMap not found, waiting 10 seconds..."
            sleep 10
          done
          
          # Force copy backup-scripts ConfigMap to each app namespace
          for namespace in immich nextcloud unifi-network-application uptime-kuma; do
            echo "Force copying backup-scripts ConfigMap to $namespace namespace..."
            
            # Delete old one first to ensure fresh copy
            kubectl delete configmap backup-scripts -n $namespace --ignore-not-found=true
            
            # Copy the current one
            kubectl get configmap backup-scripts -n backups -o yaml | \
              sed "s/namespace: backups/namespace: $namespace/" | \
              sed '/resourceVersion:/d' | \
              sed '/uid:/d' | \
              sed '/creationTimestamp:/d' | \
              kubectl apply -f -
            echo "Successfully force-copied to $namespace"
          done